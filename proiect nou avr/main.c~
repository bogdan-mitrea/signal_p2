/*********************************************
Project : Test software
**********************************************
Chip type: ATmega164A
Clock frequency: 20 MHz
Compilers:  CVAVR 2.x
*********************************************/

#include <mega164a.h>

#include <stdio.h>
#include <delay.h>  
#include <string.h> 
#include <stdlib.h>
#include "defs.h"    

//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)

// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 8
char rx_buffer0[RX_BUFFER_SIZE0];

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

//
unsigned char cnt;     // interrupts count
char key;              // key pressed
unsigned char cnt_key; // number of keys pressed
bit ok;                // check if command is ok
char build_PF = 0x00;  // PF to be built and then transmitted
char build_LED = 0x00; // LED to be built and then transmitted
char error_LED = 0x8;
char freq_test_LED = 0x4;
char DTMF_test_LED = 0x2;
char stop_LED = 0x1;

char read_keyboard(void);
void write_LED(char a);    
void write_PF(char a);
void build_PF_1(char a);
void build_PF_2(char a);
void build_PF_3(char a);
//char read_LED(void);
void MyApplication(void);

//


// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)
{
char status,data;
status=UCSR0A;
data=UDR0;
if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
   {
   rx_buffer0[rx_wr_index0++]=data;
#if RX_BUFFER_SIZE0 == 256
   // special case for receiver buffer size=256
   if (++rx_counter0 == 0) rx_buffer_overflow0=1;
#else
   if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
   if (++rx_counter0 == RX_BUFFER_SIZE0)
      {
      rx_counter0=0;
      rx_buffer_overflow0=1;
      }
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar(void)
{
char data;
while (rx_counter0==0);
data=rx_buffer0[rx_rd_index0++];
#if RX_BUFFER_SIZE0 != 256
if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
#endif
#asm("cli")
--rx_counter0;
#asm("sei")
return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 8
char tx_buffer0[TX_BUFFER_SIZE0];

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
if (tx_counter0)
   {
   --tx_counter0;
   UDR0=tx_buffer0[tx_rd_index0++];
#if TX_BUFFER_SIZE0 != 256
   if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar(char c)
{
while (tx_counter0 == TX_BUFFER_SIZE0);
#asm("cli")
if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
   {
   tx_buffer0[tx_wr_index0++]=c;
#if TX_BUFFER_SIZE0 != 256
   if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
#endif
   ++tx_counter0;
   }
else
   UDR0=c;
#asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//********************END SERIAL STUFF (USART0)  **************************************************
//*************************************************************************************************
//*******   if you need USART1, enable it in Code Wizard and copy coresponding code here  *********
//*************************************************************************************************

/*
 * Timer 1 Output Compare A interrupt is used to blink LED
 */
interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{

cnt=(cnt+1)%50;
if (cnt==0) LED1 = ~LED1; // invert LED  
//
 MyApplication();
}                                  

/*
 * main function of program
 */
void main (void)
{          
//unsigned char temp,i;

    Init_initController();  // this must be the first "init" action/call!
    #asm("sei")             // enable interrupts
    LED1 = 1;               // initial state, will be changed by timer 1
    
    cnt_key = 0;
    ok = 1;
    
    while(TRUE)
    {   
    }
    /*
        wdogtrig();            // call often else processor will reset
        if(rx_counter0)     // if a character is available on serial port USART0
        {
            temp = getchar();
            if(temp == '?') 
                printf("\r\nSwVersion:%d.%d\r\n", SW_VERSION/10, SW_VERSION%10); 
            else
                putchar(temp+1);        // echo back the character + 1 ("a" becomes "b", etc)   
        }             

        if(SW1 == 0)        // pressed
        {
            delay_ms(30);   // debounce switch
            if(SW1 == 0)    
            {                // LED will blink slow or fast
                while(SW1==0)
                    wdogtrig();    // wait for release
                // alternate between values and values/4 for OCR1A register
                // 0186 H / 4 = 0061 H
                // new frequency = old frequency * 4
                if(OCR1AH == 0x01)  
                    {TCNT1H=0; TCNT1L=0; OCR1AH = 0x00; OCR1AL = 0x61;}
                else     
                    {TCNT1H=0; TCNT1L=0; OCR1AH = 0x01; OCR1AL = 0x86;}            
            }                
        }                                       
        
        // measure time intervals on oscilloscope connected to pin TESTP
        for(i=0; i<3; i++) {
            TESTP = 1;
            delay_us(1);
            TESTP = 0;   // may check accuracy of 1us interval on oscilloscope     
        }
    } 
    */
            
}// end main loop 

/*******************************************
My application function

********************************************/
void MyApplication (void)
{
    key = read_keyboard();
    if(key != -1) { 
    
    if(ok == 0)
    {
        if(key == 0x0F) {        
            cnt_key = 0;
            ok = 1;
            write_LED(error_LED);
            return;
        } 
        if(key != 0x0F) return;
    }   
    
    switch (cnt_key)
    {
        case 0:
        {
            build_PF = 0;
            build_LED = 0;
            write_PF(0); // sets PF to initial command
            write_LED(0); // sets LEDs to LOW
            if(key == 0x0F) {        
                cnt_key = 0;
                ok = 1;
                write_LED(error_LED);
                return;
            } 
            if(key > 0x3) ok = 0;
            else {
                cnt_key++;
                build_PF_1(key);
            }  
        }
        break; 
    
        case 1:
        {
            if(key < 0x1 || key > 0x3) ok = 0;
            else switch(key)
            {
                case 1:
                {
                    cnt_key++; 
                    build_LED = freq_test_LED;
                    build_PF_2(key);
                } 
                break;
            
                case 2:
                {
                    cnt_key++;
                    build_LED = DTMF_test_LED;
                    build_PF_2(key);
                }
                break; 
            
                case 3:
                {
                    cnt_key++;
                    build_LED = stop_LED;
                    build_PF_2(key);
                } 
                break;
            }  
        }
        break;
    
        case 2:
        {
            if(build_LED == stop_LED)  
            {
                if(key != 0x0F) ok = 0;
                else { 
                    cnt_key = 0;
                    write_PF(build_PF);
                    write_LED(build_LED);
                }
            }
            else if(build_LED == freq_test_LED)
            {
                if(key > 0x7) ok = 0; 
                else { 
                    cnt_key++;
                    build_PF_3(key);
                }
            }
            else if(build_LED == DTMF_test_LED)
            { 
                cnt_key++;
                build_PF_3(key);
            }
        }
        break;
    
        case 3:
        {
            if(key != 0x0F) ok = 0;   
            else { 
                cnt_key = 0;
                write_PF(build_PF);
                write_LED(build_LED);
            }
        }
        break;    
    }
    }
} 

// initial MyApplication():   
/*
  key=read_keyboard();
if (key!=-1) 
    {
    write_LED(key);
    //write_PF(key); 
    }  
//key=read_PF();
//write_LED(key);
write_PF(key);
*/

/*******************************************
Other functions

*******************************************/

char read_keyboard(void)
{
// line 0 - PA0,  line 1 - PA1,  line 2 - PA2,  line 3 - PA3 - outputs 
char scan[4]={0xFE,0xFD,0xFB, 0xF7};
char row,col;
char cod=0xFF;

for (row=0; row<4; row++)
{
PORTA=scan[row];        //se modifica doar PA0-3
delay_us(1);
// col 0 - PA4,  col 1 - PA5,  col 2 - PA6,  col 3 - PA7 - inputs 
col=PINA>>4;
if (col!=0x0F)
    {
    if (col==0x0E) col=0;
    if (col==0x0D) col=1;
    if (col==0x0B) col=2;
    if (col==0x07) col=3;
    cod=4*row+col;
    break;
    }
}
return cod;
}

void write_LED(char a) 
{
// write PORTB bits 3-0 with a 4 bits value a3-a0
char val;
val=a & 0x0F;
PORTB=(PORTB & 0xF0) | val;
} 

void write_PF(char a)
{
// write PORTC bits 7-0 with a 8 bits value a7-a0
PORTC = a;
}

void build_PF_1(char a)
{
// write x bits 7-6 with a 2 bits value a1-a0
char val;
val = a & 0x03;
build_PF = (build_PF & 0x3F) | (val << 6);
}

void build_PF_2(char a)
{
// write x bits 5-4 with a 2 bits value a1-a0
char val;
val = a & 0x03;
build_PF = (build_PF & 0xCF) | (val << 4);
}

void build_PF_3(char a)
{
// write x bits 3-0 with a 4 bits value a3-a0
char val;
val=a & 0x0F;
build_PF = (build_PF & 0xF0) | val;
}

/*
char read_LED(void)
{
// read PORTB bits 3-0 
char val;
val= PINB & 0x0F;
return val;
}
*/

//codul cu 4 biti write, 4 biti read PF
/*  
void write_PF(char a)
{
// write PORTC bits 3-0 with a 4 bits value a3-a0
char val;
val=a & 0x0F;
PORTC=(PORTC & 0xF0) | val;
}

char read_PF(void)
{
// read PORTB bits 3-0 
char val;
val= PINB & 0x0F;
return val;
}
*/
